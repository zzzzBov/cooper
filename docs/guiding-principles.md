# Guiding Principles

The following principles are used to guide decision making for the Cooper project.

They are ordered in priority order, so that when two principles are at odds, the higher priority principle wins.

## Use the Web Platform

Engineers who learn Cooper should be gaining transferrable knowledge of the web platform. Specifically, deeper knowledge of HTML, CSS, and JavaScript.

Additionally the web platform is prioritized in the following order:

1. HTML
2. CSS
3. JavaScript

<!--

TODO:

- elaborate on why the priority of platform is HTML, CSS, then JS.
- Engineers's who learn Cooper have transferrable knowledge of the web platform (HTML, CSS, JS)
- Newer features may be used with polyfills
- DOM access
- Web Workers
- Web Components

-->

## Accessibile by Default

<!--

TODO: accessibility is for everyone. All guests should feel invited by apps built with Cooper.

- Best practices are encouraged
- Engineers are taught the right way to solve common problems.
- All examples are accessible.

-->

## Simple things are simple; complex things are possible

<!--

TODO:

- The API enables engineers to fall into the pit of success.
- APIs are streamlined toward doing things correctly.
- All APIs enable engineers to test their code with little to no scaffolding
- Testing mocks/fakes are provided with the framework.

-->

## Progressive Enhancement

<!--

TODO:

- It can be mounted in multiple places (app islands)
- Mounting supports portals
- Server-rendered markup can be hydrated with no special server-side setup.

-->

## Feature Rich

<!--

TODO:

- routing
- data management (fetching/storing)
  - IndexedDB

-->

## Opinionated

<!--

TODO:

- It uses SOLID principles.
- It is built with TypeScript.
- It uses objects made from classes with prototypal inheritance
- Unintuitive behaviors are avoided/discouraged.

-->

## Flexible

<!--

TODO:

- Modular dependencies can be swapped out.
- Multiple approaches to rendering are supported.
- Cooper can be mounted within other libraries/frameworks and versa-vice (React, Vue, Angular, etc).
- It is tooling agnostic so that engineers can author code in whatever flavor of JavaScript they prefer.
- It is server agnostic so that rendering markup server-side does not require any special tooling or training.

-->
